# bluethoot_pipe_realtime_system
READ THE LICENCE TO AVOID LEGAL PROBLEM

Request to me to share this project. 




Author
Nicola Lombardi, SW HW Engineer
Computer Engineer & Senior Python Dev.
February 2025


# Real-Time 1D Position Tracking Using Named Pipes

## Project Description

This project implements a real-time data processing pipeline to track the 1D position of a cow equipped with a Bluetooth tag. The pipeline connects multiple components via **Linux named pipes (FIFOs)** and manages the flow of data from raw measurements to a filtered output.

The cow transmits Bluetooth packets through a tag; a fixed anchor receives these transmissions and computes their **Angle of Arrival (AoA)**. By knowing both the anchor's and tag's height, and after applying filtering to smooth the data, the system computes the 1D position of the cow in real time.

The workflow is composed by 5 phases:
1. Creates Linux named pipes, to facilitate communication between the 
components. 
2. Starts the aoa_to_1d and median_filter.py processes, ensuring they read 
from and write to the correct pipes. 
3. Reads input data from input.csv, writes it to the aoa_to_1d input pipe, and 
ensures the process is properly notified when input is finished. 
4. Reads the final filtered output from median_filter.py and writes it to an 
output CSV file (output.csv). 
5. Handles process cleanup and removes the named pipes after execution.



## Static Components

| File | Description |
|-------------------------|----------------------------------------------------------------------------------------------------------------|
| `aoa_to_1d.c` |         A C program that computes the 1D position from angle and height values. It reads from and writes to named pipes. |
| `median_filter.py` |    A Python script that applies a median filter on the last second's worth of position data. |
| `pipeline.py` |         The main orchestrator that creates FIFOs, launches processes, manages data flow, and handles cleanup. |
| `input.csv` |           Sample input data in CSV format. |
| `output.csv` |          Final filtered output generated by the pipeline. |
| `test_pipe.py` |        A test suite that verifies the correctness, robustness, and performance of the system. |
| `run_all.sh` |          A Bash script that automates compilation, execution, and testing. |
| `Makefile` |            Compiles `aoa_to_1d.c` into an executable using `make`. |



## Input Format

Each row in `input.csv` contains a timestamped angle measurement:

timestamp,tag_id,angle,tag_height 1733062840000,4baf351178aa9b0e,-30,1.2



## How to Run

### 1. Compilation

To compile the C component:

Run the bash script 
make
Alternatively, manually:
gcc -o aoa_to_1d aoa_to_1d.c -lm


### 2. Execute the Pipeline
Run the main Python orchestrator:

python3 pipeline.py

This creates the FIFO pipes, starts the sub-processes, streams input and output, and performs cleanup.


## How to Run the Testing for the Test Plan

A comprehensive test plan is provided in test_pipe.py, covering the following areas:

1. Creation of FIFO pipes

2. Launching of external processes

3. Data transmission between components (via files instead of FIFOs, where needed)

4. Correct processing of known input data

5. Validation of generated output

6. Cleanup of processes and FIFOs

7. Robustness to malformed or corrupted input

8. Performance under large datasets

9. Concurrency with simultaneous inputs

10. Automated test of one complete known case

Run All Tests

python3 test_pipe.py

Or run the full automation: bash

./run_all.sh

# FIFO Architecture


[input.csv]
    ‚Üì
[input_pipe.fifo]
    ‚Üì
[aoa_to_1d]
    ‚Üì
[output_pipe_aoa.fifo]
    ‚Üì
[median_filter.py]
    ‚Üì
[output_pipe_filter.fifo]
    ‚Üì
[output.csv]

# Assumptions
1. The system runs on Linux or WSL, with FIFO support.

2. CSV inputs are assumed to be mostly well-formed.

3. Processes properly handle EOF and pipe input.

4. Malformed lines are skipped without halting processing.

5. The pipeline is linear and sequential, but concurrency is tested in parallel scenarios.

# Requirements
Skills in Named Pipe both in C and Python
Python 3.7 or higher in PyCharm Community Edition
GCC (to compile the C source)
Linux or WSL environment
Setup of the WSL
SOLID Principles are not mandatory in this application


# Cleanup
Temporary files and named pipes are automatically removed by pipeline.py and run_all.sh.



# Linux pills

The typical C compiler in Linux system is gcc (GNU C Compiler)

Syntax to build a binary executable
 $ gcc-o <exec_name> <source_code>.c

Syntax to produce object code
 $ gcc-c <source_code>.c
 the output file is named <source_code>.o

Syntax to both build a binary executable and run it:
$ gcc <source_code>.c -o exe_name && ./exe_name

Syntax to install python:
$ sudo apt install python3-pip

Syntax to discover python version
$ python3 --version

Syntax to install gcc:
$ sudo apt update && sudo apt install build-essential

Syntax to install pandas:
$ sudo apt install python3-pandas

Syntax to run python script on bash (shell):
$ python3 pipeline.py

Syntax to know the state of WSL (e.g. Docker) on Windows PowerShell:
> wsl -l -v


## Particular case: aoa_to_1d.c  contains math.h (see below)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>


Including  library  functions into  a program
gcc-o <exec> <source>.c -L<dir> -l<name>

The -l options is used to tell the compiler that  some functions in the source code have their 
object code in the lib<name>.a
 
the library is not in a standard directory, the directory must be specified through the  -L <dir>
option.

Standard libraries are part of the Operating System, while other 
libraries are distributed with the compiler; libcis the default C library containing input and output functions 
such as printf, scanf, open, read, write, etc.

Indeed, at first glance the syntax:

gcc -o aoa_to_1d aoa_to_1d.c

should be sufficient to correctly compile the file aoa_to_1d.c. However, in this case, it is necessary to add the -lm flag to link the math library (libm), and here is why "  gcc -o aoa_to_1d aoa_to_1d.c -lm  " is correct and mandatory!



## C language pills

In C, you can operate on files only in terms of sequences
of bytes: stream
There are no high-level functions like in other languages ‚Äã‚Äãsuch as Python that mimics the write() and read() of C.
In the C code of the project we use pointers.

To read and write to files, a pointer to a derived type is used
FILE *fileptr; //pointer to the file

This procedure is identical whether you use a file or a pipe.


(1) Example of pipe:

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>//for open()
#include <string.h> //for sprintf() : the output is a string
#include <sys/stat.h>

int main(){
	int x;
	int fd_pipe[2];//one for reading and one for writing
	char str[100];
	
	pipe(fd_pipe);//creating of communication channel in the parent channel
	printf("Please type an integer number: ");
	scanf("%d",&x);

	switch(fork()){
		case 0:
			//Parent's fd inheritance
			close(fd_pipe[0]);//because it has to write
			sprintf(str,"[CHILD] The new number is %d\n",x+5);
			write(fd_pipe[1],str,strlen(str));
			
			return 0;
		default:
			close(fd_pipe[1]);//because it has to read
			read(fd_pipe[0],str,sizeof(str));//I dont need to loop
			printf("[PARENT] The Child says: %s\n",str);
	}
}


## Half duplex
Parent		    ___________________________________________________       Child
  fd[1]--->read ---------------------------------------------------fd[1]--->write
  fd[0]--->write---------------------------------------------------fd[0]--->read          
		         ___________________________________________________

## Full duplex

/*		BIDIRECTIONAL pipe

					CHANNEL
Parent		___________________________________________________                   Child
                <-----------------------------------------------------------fd_pipe_c2p[0]--->read
                <-----------------------------------------------------------fd_pipe_c2p[1]--->write         
fd_pipe_p2c[0]--->read--------------------------------------------------->
fd_pipe_p2c[1]--->write-------------------------------------------------->
		___________________________________________________


*/



(2) Another example of pipe: my script oao_to_1d.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define MAX_LINE_LENGTH 256

int main(int argc, char *argv[]) {
    if (argc != 4) {
        fprintf(stderr, "Usage: %s <input_pipe> <output_pipe> <h_anchor>\n", argv[0]);
        return EXIT_FAILURE;
    }

    const char *input_pipe = argv[1];
    const char *output_pipe = argv[2];
    double h_anchor = atof(argv[3]);

    FILE *input_fp = fopen(input_pipe, "r");
    if (!input_fp) {
        perror("Error opening input pipe");
        return EXIT_FAILURE;
    }

    FILE *output_fp = fopen(output_pipe, "w");
    if (!output_fp) {
        perror("Error opening output pipe");
        fclose(input_fp);
        return EXIT_FAILURE;
    }

    char line[MAX_LINE_LENGTH];
    while (fgets(line, sizeof(line), input_fp)) {
        unsigned long long timestamp;
        char tag_id[17];
        double angle, h_tag, x;
        
        if (sscanf(line, "%llu,%16[^,],%lf,%lf", &timestamp, tag_id, &angle, &h_tag) != 4) {
            fprintf(stderr, "Error parsing line: %s", line);
            continue;
        }

        double alpha_rad = angle * M_PI / 180.0;
        x = (h_anchor - h_tag) * tan(alpha_rad);

        fprintf(output_fp, "%llu,%s,%.2f\n", timestamp, tag_id, x);
        fflush(output_fp);
    }

    fclose(input_fp);
    fclose(output_fp);
    return EXIT_SUCCESS;
}


In C you can operate on files only in terms of sequences
of bytes: stream
There are no high-level functions like in other languages ‚Äã‚Äãsuch as Python that mimics the write() and read() of C.
In the C code of the project we use pointers.

To read and write to files we use a pointer to a derived type
FILE *fileptr; //pointer to the file

This procedure is identical whether you use a file or a pipe.

‚úÖ Script 2: aoa_to_1d.c
üìå Features: It uses named pipes (FIFO), i.e. special files in the filesystem.

The program takes the names of the pipes as command line arguments.

It communicates between separate processes (not necessarily parent-child) via FIFO files created before running the script.

üîç How it works:

FILE *input_fp = fopen(input_pipe, "r");
FILE *output_fp = fopen(output_pipe, "w");
These pipes must already exist, for example created with:

mkfifo pipe_input
mkfifo pipe_output


The process reads from one pipe (input_pipe) and writes the processing to another (output_pipe).

There is no fork() in the code ‚Üí the processes involved are launched separately but communicate with each other via these special files.

üß† Key concept:
Persistent inter-process communication, based on FIFO files in the filesystem.

‚úÖ Script 1: pipe.c
üìå Features:
Uses unnamed pipes, i.e. anonymous pipes created with pipe(fd_pipe).

It works internally between a parent process and its child process created with fork().

It is all autonomous, no files in the filesystem.

üîç How it works:

pipe(fd_pipe);
fork();

Child writes to pipe (fd_pipe[1])

Father reads from pipe (fd_pipe[0])

Data (integer plus 5) is passed directly into shared memory via pipe.

üß† Key concept:
Parent-child communication based on anonymous pipes in RAM. It is temporary and limited to the lifetime of the process.

üîÑ Differences summary:
Feature                        aoa_to_1d.c   (2)            pipe.c  (1)
Pipe type                      Named pipe (FIFO)             Unnamed pipe (anonymous pipe)
Communication                  between separate processes    Parent process ‚Üî child (fork)
Pipe creation                  Externally with mkfifo        Internally with pipe()
I/O mechanism                  fopen(), fprintf(), fgets()   read(), write()

Persistence Can persist in filesystem, Temporary, exists only in RAM




